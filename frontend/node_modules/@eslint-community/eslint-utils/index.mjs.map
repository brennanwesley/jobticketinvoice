{"version":3,"file":"index.mjs","sources":["src/get-innermost-scope.mjs","src/find-variable.mjs","src/token-predicate.mjs","src/get-function-head-location.mjs","src/get-static-value.mjs","src/get-string-if-constant.mjs","src/get-property-name.mjs","src/get-function-name-with-kind.mjs","src/has-side-effect.mjs","src/is-parenthesized.mjs","src/pattern-matcher.mjs","src/reference-tracker.mjs","src/index.mjs"],"sourcesContent":["/** @typedef {import(\"eslint\").Scope.Scope} Scope */\n/** @typedef {import(\"estree\").Node} Node */\n\n/**\n * Get the innermost scope which contains a given location.\n * @param {Scope} initialScope The initial scope to search.\n * @param {Node} node The location to search.\n * @returns {Scope} The innermost scope.\n */\nexport function getInnermostScope(initialScope, node) {\n    const location = /** @type {[number, number]} */ (node.range)[0]\n\n    let scope = initialScope\n    let found = false\n    do {\n        found = false\n        for (const childScope of scope.childScopes) {\n            const range = /** @type {[number, number]} */ (\n                childScope.block.range\n            )\n\n            if (range[0] <= location && location < range[1]) {\n                scope = childScope\n                found = true\n                break\n            }\n        }\n    } while (found)\n\n    return scope\n}\n","import { getInnermostScope } from \"./get-innermost-scope.mjs\"\n/** @typedef {import(\"eslint\").Scope.Scope} Scope */\n/** @typedef {import(\"eslint\").Scope.Variable} Variable */\n/** @typedef {import(\"estree\").Identifier} Identifier */\n\n/**\n * Find the variable of a given name.\n * @param {Scope} initialScope The scope to start finding.\n * @param {string|Identifier} nameOrNode The variable name to find. If this is a Node object then it should be an Identifier node.\n * @returns {Variable|null} The found variable or null.\n */\nexport function findVariable(initialScope, nameOrNode) {\n    let name = \"\"\n    /** @type {Scope|null} */\n    let scope = initialScope\n\n    if (typeof nameOrNode === \"string\") {\n        name = nameOrNode\n    } else {\n        name = nameOrNode.name\n        scope = getInnermostScope(scope, nameOrNode)\n    }\n\n    while (scope != null) {\n        const variable = scope.set.get(name)\n        if (variable != null) {\n            return variable\n        }\n        scope = scope.upper\n    }\n\n    return null\n}\n","/** @typedef {import(\"eslint\").AST.Token} Token */\n/** @typedef {import(\"estree\").Comment} Comment */\n/** @typedef {import(\"./types.mjs\").ArrowToken} ArrowToken */\n/** @typedef {import(\"./types.mjs\").CommaToken} CommaToken */\n/** @typedef {import(\"./types.mjs\").SemicolonToken} SemicolonToken */\n/** @typedef {import(\"./types.mjs\").ColonToken} ColonToken */\n/** @typedef {import(\"./types.mjs\").OpeningParenToken} OpeningParenToken */\n/** @typedef {import(\"./types.mjs\").ClosingParenToken} ClosingParenToken */\n/** @typedef {import(\"./types.mjs\").OpeningBracketToken} OpeningBracketToken */\n/** @typedef {import(\"./types.mjs\").ClosingBracketToken} ClosingBracketToken */\n/** @typedef {import(\"./types.mjs\").OpeningBraceToken} OpeningBraceToken */\n/** @typedef {import(\"./types.mjs\").ClosingBraceToken} ClosingBraceToken */\n/**\n * @template {string} Value\n * @typedef {import(\"./types.mjs\").PunctuatorToken<Value>} PunctuatorToken\n */\n\n/** @typedef {Comment | Token} CommentOrToken */\n\n/**\n * Creates the negate function of the given function.\n * @param {function(CommentOrToken):boolean} f - The function to negate.\n * @returns {function(CommentOrToken):boolean} Negated function.\n */\nfunction negate(f) {\n    return (token) => !f(token)\n}\n\n/**\n * Checks if the given token is a PunctuatorToken with the given value\n * @template {string} Value\n * @param {CommentOrToken} token - The token to check.\n * @param {Value} value - The value to check.\n * @returns {token is PunctuatorToken<Value>} `true` if the token is a PunctuatorToken with the given value.\n */\nfunction isPunctuatorTokenWithValue(token, value) {\n    return token.type === \"Punctuator\" && token.value === value\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ArrowToken} `true` if the token is an arrow token.\n */\nexport function isArrowToken(token) {\n    return isPunctuatorTokenWithValue(token, \"=>\")\n}\n\n/**\n * Checks if the given token is a comma token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is CommaToken} `true` if the token is a comma token.\n */\nexport function isCommaToken(token) {\n    return isPunctuatorTokenWithValue(token, \",\")\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is SemicolonToken} `true` if the token is a semicolon token.\n */\nexport function isSemicolonToken(token) {\n    return isPunctuatorTokenWithValue(token, \";\")\n}\n\n/**\n * Checks if the given token is a colon token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ColonToken} `true` if the token is a colon token.\n */\nexport function isColonToken(token) {\n    return isPunctuatorTokenWithValue(token, \":\")\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is OpeningParenToken} `true` if the token is an opening parenthesis token.\n */\nexport function isOpeningParenToken(token) {\n    return isPunctuatorTokenWithValue(token, \"(\")\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ClosingParenToken} `true` if the token is a closing parenthesis token.\n */\nexport function isClosingParenToken(token) {\n    return isPunctuatorTokenWithValue(token, \")\")\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is OpeningBracketToken} `true` if the token is an opening square bracket token.\n */\nexport function isOpeningBracketToken(token) {\n    return isPunctuatorTokenWithValue(token, \"[\")\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ClosingBracketToken} `true` if the token is a closing square bracket token.\n */\nexport function isClosingBracketToken(token) {\n    return isPunctuatorTokenWithValue(token, \"]\")\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is OpeningBraceToken} `true` if the token is an opening brace token.\n */\nexport function isOpeningBraceToken(token) {\n    return isPunctuatorTokenWithValue(token, \"{\")\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is ClosingBraceToken} `true` if the token is a closing brace token.\n */\nexport function isClosingBraceToken(token) {\n    return isPunctuatorTokenWithValue(token, \"}\")\n}\n\n/**\n * Checks if the given token is a comment token or not.\n * @param {CommentOrToken} token - The token to check.\n * @returns {token is Comment} `true` if the token is a comment token.\n */\nexport function isCommentToken(token) {\n    return [\"Block\", \"Line\", \"Shebang\"].includes(token.type)\n}\n\nexport const isNotArrowToken = negate(isArrowToken)\nexport const isNotCommaToken = negate(isCommaToken)\nexport const isNotSemicolonToken = negate(isSemicolonToken)\nexport const isNotColonToken = negate(isColonToken)\nexport const isNotOpeningParenToken = negate(isOpeningParenToken)\nexport const isNotClosingParenToken = negate(isClosingParenToken)\nexport const isNotOpeningBracketToken = negate(isOpeningBracketToken)\nexport const isNotClosingBracketToken = negate(isClosingBracketToken)\nexport const isNotOpeningBraceToken = negate(isOpeningBraceToken)\nexport const isNotClosingBraceToken = negate(isClosingBraceToken)\nexport const isNotCommentToken = negate(isCommentToken)\n","import { isArrowToken, isOpeningParenToken } from \"./token-predicate.mjs\"\n/** @typedef {import(\"eslint\").Rule.Node} RuleNode */\n/** @typedef {import(\"eslint\").SourceCode} SourceCode */\n/** @typedef {import(\"eslint\").AST.Token} Token */\n/** @typedef {import(\"estree\").Function} FunctionNode */\n/** @typedef {import(\"estree\").FunctionDeclaration} FunctionDeclaration */\n/** @typedef {import(\"estree\").FunctionExpression} FunctionExpression */\n/** @typedef {import(\"estree\").SourceLocation} SourceLocation */\n/** @typedef {import(\"estree\").Position} Position */\n\n/**\n * Get the `(` token of the given function node.\n * @param {FunctionExpression | FunctionDeclaration} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {Token} `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n    return node.id\n        ? /** @type {Token} */ (\n              sourceCode.getTokenAfter(node.id, isOpeningParenToken)\n          )\n        : /** @type {Token} */ (\n              sourceCode.getFirstToken(node, isOpeningParenToken)\n          )\n}\n\n/**\n * Get the location of the given function node for reporting.\n * @param {FunctionNode} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {SourceLocation|null} The location of the function node for reporting.\n */\nexport function getFunctionHeadLocation(node, sourceCode) {\n    const parent = /** @type {RuleNode} */ (node).parent\n\n    /** @type {Position|null} */\n    let start = null\n    /** @type {Position|null} */\n    let end = null\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        const arrowToken = /** @type {Token} */ (\n            sourceCode.getTokenBefore(node.body, isArrowToken)\n        )\n\n        start = arrowToken.loc.start\n        end = arrowToken.loc.end\n    } else if (\n        parent.type === \"Property\" ||\n        parent.type === \"MethodDefinition\" ||\n        parent.type === \"PropertyDefinition\"\n    ) {\n        start = /** @type {SourceLocation} */ (parent.loc).start\n        end = getOpeningParenOfParams(node, sourceCode).loc.start\n    } else {\n        start = /** @type {SourceLocation} */ (node.loc).start\n        end = getOpeningParenOfParams(node, sourceCode).loc.start\n    }\n\n    return {\n        start: { ...start },\n        end: { ...end },\n    }\n}\n","/* globals globalThis, global, self, window */\n\nimport { findVariable } from \"./find-variable.mjs\"\n/** @typedef {import(\"./types.mjs\").StaticValue} StaticValue */\n/** @typedef {import(\"eslint\").Scope.Scope} Scope */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.Node} TSESTreeNode */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.AST_NODE_TYPES} TSESTreeNodeTypes */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.MemberExpression} MemberExpression */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.Property} Property */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.RegExpLiteral} RegExpLiteral */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.BigIntLiteral} BigIntLiteral */\n/** @typedef {import(\"@typescript-eslint/types\").TSESTree.Literal} Literal */\n\nconst globalObject =\n    typeof globalThis !== \"undefined\"\n        ? globalThis\n        : // @ts-ignore\n        typeof self !== \"undefined\"\n        ? // @ts-ignore\n          self\n        : // @ts-ignore\n        typeof window !== \"undefined\"\n        ? // @ts-ignore\n          window\n        : typeof global !== \"undefined\"\n        ? global\n        : {}\n\nconst builtinNames = Object.freeze(\n    new Set([\n        \"Array\",\n        \"ArrayBuffer\",\n        \"BigInt\",\n  